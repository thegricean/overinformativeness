// run using:
// webppl BDA.wppl --require ./refModule/

// Fix some configuration options
var globalConfig = {
  'modelVersion' : 'colorSize', // M1: colorSize, M2: typicality, M3: nominal
  'storePredictives' : false,
  'outputFileName' : 'testing'
};

var data = refModule.readCSV("./bdaInput/bda_data.csv");
console.log("Loading data complete...",+data.length+" data points");

var conditions = refModule.readCSV("./bdaInput/unique_conditions.csv");
console.log("Loading unique conditions complete..."+conditions.length+" conditions");

// Cache so we don't have to incur cost of loading json every iteration
var realValuedLexicon = refModule.getLexicon('realValued');

// TODO:
// 1. load correct taxonomy for nominal
var paramPrior = function(modelType) {
  // Params shared by all versions of the model
  var baseParams = {
    alpha : uniform(0, 1),
    costWeight : uniform(0, 5),
    lexicon : refModule.constructLexicon(modelType)
  };

  var specificParams = (modelType === 'colorSize' ? {

    colorTyp :        uniform(.5,  1),
    sizeTyp :         uniform(.5,  1),
    colorVsSizeCost : uniform( 0,  1)
    
  } : modelType === 'typicality' ? {

    lengthVsFreqCost: uniform( 0,  1),
    typWeight :       uniform( 0, 10),
    colorPenalty:     uniform(-1,  1),
    typePenalty:      uniform(-1,  1)
    
  } : modelType === 'nominal' ? {

    lengthVsFreqCost: uniform( 0,  1),
    typWeight :       uniform( 0, 10),
    taxonomy :        refModule.getTypicalityTax()
    
  } : console.error('unknown modelType: ' + modelType));

  return extend(globalConfig, baseParams, specificParams);
};

var modelAnalysis = function() {

  var params = paramPrior(globalConfig.modelVersion);

  var speakerModel = initializeModel(params);
  // var score = reduce(function(conditionObj, memo) {
  //   // Extract condition information
  //   var conditionName = conditionObj.conditionName;
  //   var context = [[conditionObj.t_color, conditionObj.t_type],
  // 		   [conditionObj.d1_color, conditionObj.d1_type],
  // 		   [conditionObj.d2_color, conditionObj.d2_type]];
  //   var target = context[0];

  //   // Run model
  //   var modelParams = extend(params, globalConfig, {'lexicon': realValuedLexicon});
  //   var speakerModel = initializeModel(modelParams);
  //   var modelOutput = speakerModel(target, context);
    
  //   // Store predives
  //   if(globalConfig.storePredictives) {
  //     foreach(modelOutput.support(), function(s){
  // 	var key = _.values(conditionObj).concat(s);
  // 	var newPair = _.zipObject([key], [Math.exp(modelOutput.score(s))]);
  // 	globalStore.predictives = extend(globalStore.predictives, newPair);
  //     });
  //   }
    
  //   // condition on data
  //   var itemData = refModule.getSubset(data, conditionObj);
  //   return memo + reduce(function(datum, memo) {
  //     return modelOutput.score(datum.utterance) + memo;
  //   }, 0, itemData);
  // }, 0, conditions);

  // console.log(params);
  // console.log(score);

  // factor(score);
  // return {predictive: globalStore.predictives, params : params};
  return params;
};

var outputERP = Infer({method:'MCMC', samples: 500, lag: 2, burn: 100, verbose: true},
		      modelAnalysis);

refModule.bayesianErpWriter(outputERP, "./bdaOutput/" + globalConfig.outputFileName);
