// run using:
// webppl BDA.wppl --require ./refModule/

var data = refModule.readCSV("./bdaInput/bda_data.csv");
console.log("Loading data complete...",+data.length+" data points");

var conditions = refModule.readCSV("./bdaInput/unique_conditions.csv");
console.log("Loading unique conditions complete..."+conditions.length+" conditions");

var typics = refModule.readCSV("./bdaInput/meantyp_short.csv");
console.log(typics);

// Cache so we don't have to incur cost of loading json every iteration
var realValuedLexicon = refModule.getLexicon('realValued');

// Fix some configuration options
var globalConfig = {
  'lexiconChoice' : 'empirical',
  'costsChoice' : 'empirical',
  'noiseType' : 'none',
  'storePredictives' : false,
  'outputFileName' : 'empiricalCosts_noiseAdd'
};

var modelAnalysis = function() {
  // Params for all versions of the model
  var baseParams = {
    alpha : 1,//uniformDraw(_.range(0, 20, 2)),
    colorCost : 2,//uniformDraw(_.range(-3, 3.1, 1.5)),
    typeCost : 3//uniformDraw(_.range(-3, 3.1, 1.5))
  };

  // Additional params for particular versions
  var empCostParams = (globalConfig.costsChoice == 'empirical' ? {
    lengthWeight : uniformDraw([.25,.75])//_.range(0, 1.01, 0.25))
  } : {});

  var empTypicalitiesParams = (globalConfig.lexiconChoice == 'empirical' ? {
    typWeight : 5//uniformDraw(_.range(0, 10.1, 2))
  } : {});
  
  var noiseParams = (globalConfig.noiseType != 'none' ? {
    noiseRate : uniformDraw(_.range(0, 1.1, 0.5))
  } : {});

  // Combine params together
  var params = extend(baseParams, empCostParams, noiseParams, empTypicalitiesParams);
  console.log(params)
  
  var predictionsPerCondition = _.flatten(map(function(conditionObj) {
    // Extract condition information
    var conditionInfo = _.values(conditionObj).concat(_.values(params));
    var conditionName = conditionObj.conditionName;
    var context = [[conditionObj.t_color, conditionObj.t_type],
		   [conditionObj.d1_color, conditionObj.d1_type],
		   [conditionObj.d2_color, conditionObj.d2_type]];
    var target = context[0];

    // Run model
    var modelParams = extend(params, globalConfig, {'lexicon': realValuedLexicon});
    var speakerModel = initializeModel(modelParams);
    var modelOutput = speakerModel(target, context);
    
    // Store predictives for each datapoint
    return map(function(s){
      return conditionInfo.concat(s).concat(Math.exp(modelOutput.score(s)));
    }, modelOutput.support());
  }, conditions));

  // TODO: write function transforming this huge list of every condition to just the
  // relevant datapoints for making our visualizations
  // before: condition, targetColor, targetType, distColor1, distType1, distColor2, distType2, alpha, colorCost, typeCost, lengthWeight, typWeight, utterance, probability
  // after: condition, targetTypicality (typicality of color for object, right now easier: color and object for later look-up), alpha, colorCost, typeCost, lengthWeight, typWeight, utterance(Type), probability
  var collapsedPredictions = 
    map(function(chunk){
      var target = chunk[1].concat("_").concat(chunk[2]);
      // TODO: get rid of all the undefined 
      var typ = map(function(blob){
        if (blob['Item'] == chunk[2] && blob['Color'] == chunk[1]) {
          return blob['Typicality'];
        };
      },typics);
      console.log("target");
      console.log(target);
      console.log("typ");
      console.log(typ);
      console.log("");
      // take out all chunks where utterance doesn't correspond to target (all non-fitting utterances)
      // problem returns undefined when not in if statement
      if (chunk[12] == chunk[1] || chunk[12] == chunk[2] || chunk[12] == target){
        // [0] condition - stays
        // [1] targetColor [2] targetType - transformed into 1 string
        // [3] [4] [5] [6] dist - get rid of
        // [7] [8] [9] [10] [11] params - stay
        // [12] utterance - becomes utteranceType or stays
        // [13] probability - stays
        var cond = chunk[0];
        var al = chunk[7];
        var cc = chunk[8];
        var tc = chunk[9];
        var lw = chunk[10];
        var tw = chunk[11];
        var uttType = chunk[12] == chunk[1] ? 'colorOnly' : chunk[12] == chunk[2] ? 'typeOnly' : 'colorType';
        var prob = chunk[13];
        return [cond, target, al, cc, tc, lw, tw, uttType, prob];
      };
    },predictionsPerCondition);
  // console.log("collapsedPredictions");
  // console.log(collapsedPredictions);
  return collapsedPredictions;
};

var outputERP = Infer({method:'enumerate'}, modelAnalysis);

refModule.bayesianErpWriter(outputERP, "./bdaOutput/" + globalConfig.outputFileName);
